<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dynamic Karaoke â€” Full Site</title>
  <style>
    :root { --bg:#0b1020; --card:#121a32; --text:#e8ecff; --muted:#9aa5d1; --accent:#7aa2ff; }
    *{box-sizing:border-box}
    body{margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text)}
    header{padding:24px 16px; text-align:center}
    header h1{margin:0 0 6px; font-weight:800; letter-spacing:.3px}
    header p{margin:0; color:var(--muted)}
    .container{max-width:1024px; margin:0 auto; padding:16px; display:grid; gap:16px}
    .card{background:var(--card); border:1px solid #1f2a4a; border-radius:16px; padding:16px}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    .col{flex:1 1 260px}
    label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px}
    input[type="file"], input[type="text"]{width:100%; padding:10px; background:#0d1429; color:var(--text); border:1px solid #2c3b6e; border-radius:10px}
    button{background:var(--accent); color:#08122b; border:none; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer}
    button.secondary{background:#20315f; color:#e8ecff}
    button:disabled{opacity:.5; cursor:not-allowed}
    .controls{display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:12px}
    .ctrl{background:#0d1429; border:1px solid #1f2a4a; border-radius:12px; padding:12px}
    .ctrl input[type="range"]{width:100%}
    .small{font-size:12px; color:var(--muted)}
    .status{display:flex; gap:16px; flex-wrap:wrap; align-items:center}
    .pill{padding:6px 10px; border-radius:999px; font-size:12px; background:#0d1429; border:1px solid #1f2a4a}
    .on{background:#183d1c; border-color:#2b6a31; color:#a8ffb0}
    .off{background:#3a1a1a; border-color:#6a2b2b; color:#ffb0b0}
    #meter{width:100%; height:14px; background:#0d1429; border:1px solid #1f2a4a; border-radius:999px; overflow:hidden}
    #bar{height:100%; width:0%; background:linear-gradient(90deg,#6fb6ff,#8be3ff)}
    .footer{color:var(--muted); text-align:center; padding:12px}
    code.k{background:#0d1429; padding:0 6px; border-radius:6px; border:1px solid #1f2a4a}
    .lyrics{display:grid; place-items:center; min-height:180px; text-align:center}
    .lyr-box{max-width:820px}
    .lyr-current{font-size:28px; font-weight:800; letter-spacing:.3px; margin:6px 0}
    .lyr-faded{color:#9aa5d1aa; font-size:16px; margin:4px 0}
    .art{width:64px; height:64px; border-radius:12px; border:1px solid #1f2a4a; object-fit:cover}
  </style>
</head>
<body>
  <header>
    <h1>Dynamic Karaoke â€” type, upload, or stream ðŸŽ¤</h1>
    <p>Mic quiet â‡’ fade <b>vocal stem</b> in. Mic loud â‡’ fade it out. Choose: upload full songs, search 30â€‘sec previews, or connect Spotify (full songs, overlay disabled).</p>
  </header>

  <div class="container">
    <!-- SEARCH (iTunes 30s preview) -->
    <div class="card">
      <div class="row">
        <div class="col" style="flex:2 1 420px">
          <label>Search a song (title or "title â€” artist")</label>
          <input id="songQuery" type="text" placeholder="e.g., Antiâ€‘Hero â€” Taylor Swift" />
        </div>
        <div class="col" style="flex:0 0 auto"><button id="searchBtn">ðŸ”Ž Search & Autoâ€‘Load</button></div>
        <div class="col" style="flex:0 0 auto"><img id="artwork" class="art" alt="artwork" /></div>
      </div>
      <div class="small" style="margin-top:6px">Search uses Apple's public iTunes previews (â‰ˆ30s). For full songs with overlay, use local files. For full songs via Spotify, use Spotify mode (overlay disabled).</div>
    </div>

    <!-- SPOTIFY MODE -->
    <div class="card">
      <h3 style="margin:0 0 8px">Spotify mode (Premium required; overlay disabled)</h3>
      <div class="row">
        <div class="col" style="flex:0 0 220px"><button id="spLoginBtn" class="secondary">ðŸ”— Connect Spotify</button></div>
        <div class="col">
          <input id="spTrack" type="text" placeholder="spotify:track:... or https://open.spotify.com/track/..." />
        </div>
        <div class="col" style="flex:0 0 180px"><button id="spPlayBtn" disabled>â–¶ Play on Spotify</button></div>
      </div>
      <div class="small">After connecting, paste a Spotify track URL/URI and press Play. We cannot mix/alter Spotify audio; lyrics still work.</div>
    </div>

    <!-- FILE UPLOADS (full length, with overlay) -->
    <div class="card">
      <div class="row">
        <div class="col">
          <label>Oneâ€‘file Upload (mix of music + vocals) â€” weâ€™ll autoâ€‘create a backingâ€‘only track</label>
          <input id="mixedFile" type="file" accept="audio/*" />
        </div>
      </div>
      <hr style="border:none;border-top:1px solid #1f2a4a; margin:12px 0" />
      <div class="row">
        <div class="col">
          <label>Backing Track (instrumental)</label>
          <input id="backingFile" type="file" accept="audio/*" />
        </div>
        <div class="col">
          <label>Vocal Stem (aligned)</label>
          <input id="vocalFile" type="file" accept="audio/*" />
        </div>
      </div>
      <div class="row" style="margin-top:12px">
        <button id="startBtn" disabled>â–¶ Start</button>
        <button id="stopBtn" class="secondary" disabled>â–  Stop</button>
        <button id="calBtn" class="secondary" disabled>ðŸ›  Calibrate Noise</button>
        <span class="small">Use <b>headphones</b>. Your browser will ask for mic access.</span>
      </div>
    </div>

    <!-- CONTROLS -->
    <div class="card">
      <div class="controls">
        <div class="ctrl">
          <label>Quiet Threshold (<span id="thrVal">0.010</span> RMS)</label>
          <input id="thr" type="range" min="0.001" max="0.050" step="0.001" value="0.010" />
          <div class="small">Raise if vocals keep coming in; lower if they never come in.</div>
        </div>
        <div class="ctrl">
          <label>Hold Time (<span id="holdVal">300</span> ms)</label>
          <input id="hold" type="range" min="100" max="1200" step="50" value="300" />
          <div class="small">How long the mic must be quiet before vocals fade in.</div>
        </div>
        <div class="ctrl">
          <label>Fade Time (<span id="fadeVal">60</span> ms)</label>
          <input id="fade" type="range" min="10" max="500" step="10" value="60" />
          <div class="small">Crossfade speed between off/on states.</div>
        </div>
      </div>
    </div>

    <!-- STATUS -->
    <div class="card">
      <div class="status">
        <div id="statePill" class="pill off">Vocal Overlay: OFF</div>
        <div class="pill">RMS: <span id="rmsText">0.000</span></div>
        <div class="pill">Context SR: <span id="srText">â€”</span></div>
        <div class="pill" id="songMeta">&nbsp;</div>
      </div>
      <div id="meter" style="margin-top:10px"><div id="bar"></div></div>
    </div>

    <!-- LYRICS -->
    <div class="card lyrics">
      <div class="lyr-box">
        <div class="small" style="margin-top:8px">Tip: upload a timed <code class="k">.lrc</code> for perfect sync. We also autoâ€‘fetch from LRCLIB on search.</div>
        <div class="row" style="justify-content:center; gap:8px; margin-bottom:10px">
          <input id="lyricsFile" type="file" accept=".lrc,.txt" />
          <button id="clearLyrics" class="secondary">Clear Lyrics</button>
        </div>
        <div class="lyr-faded" id="lyrPrev">&nbsp;</div>
        <div class="lyr-current" id="lyrCurr">(no lyrics loaded)</div>
        <div class="lyr-faded" id="lyrNext">&nbsp;</div>
      </div>
    </div>

    <div class="card">
      <h3 style="margin-top:0">Notes</h3>
      <ul>
        <li>Local files: full length, overlay enabled. Centerâ€‘cancellation works best on stereo with centered vocals.</li>
        <li>Search: 30â€‘sec previews (legal). Autoâ€‘lyrics via LRCLIB if available.</li>
        <li>Spotify mode: full songs for Premium users; overlay disabled by design.</li>
      </ul>
    </div>

  </div>

  <script>
  // -------------------- UI refs --------------------
  const els = {
    // search
    q: document.getElementById('songQuery'),
    search: document.getElementById('searchBtn'),
    art: document.getElementById('artwork'),
    songMeta: document.getElementById('songMeta'),
    // upload
    mixed: document.getElementById('mixedFile'),
    backing: document.getElementById('backingFile'),
    vocal: document.getElementById('vocalFile'),
    // transport
    start: document.getElementById('startBtn'),
    stop: document.getElementById('stopBtn'),
    cal: document.getElementById('calBtn'),
    // controls
    thr: document.getElementById('thr'), thrVal: document.getElementById('thrVal'),
    hold: document.getElementById('hold'), holdVal: document.getElementById('holdVal'),
    fade: document.getElementById('fade'), fadeVal: document.getElementById('fadeVal'),
    // status
    rmsText: document.getElementById('rmsText'), srText: document.getElementById('srText'),
    statePill: document.getElementById('statePill'), bar: document.getElementById('bar'),
    // lyrics
    lyrFile: document.getElementById('lyricsFile'),
    lyrPrev: document.getElementById('lyrPrev'),
    lyrCurr: document.getElementById('lyrCurr'),
    lyrNext: document.getElementById('lyrNext'),
    lyrClear: document.getElementById('clearLyrics'),
    // spotify
    spLoginBtn: document.getElementById('spLoginBtn'),
    spPlayBtn: document.getElementById('spPlayBtn'),
    spTrackInp: document.getElementById('spTrack'),
  };

  // -------------------- Audio graph state --------------------
  let ctx, backingBuf, vocalBuf, backingSrc, vocalSrc, backingGain, vocalGain;
  let micStream, analyser, logicTimer;
  let overlayOn = false;
  let spotifyMode = false; // when true, disable overlay/mixing

  // Lyrics state
  let lyrics = []; // {t: seconds|null, text}
  let lyricsTimer = null; let autoScrollIdx = 0; let startWallClock = 0;

  function updateUI(){
    els.thrVal.textContent = Number(els.thr.value).toFixed(3);
    els.holdVal.textContent = els.hold.value;
    els.fadeVal.textContent = els.fade.value;
  }
  ['change','input'].forEach(ev=>{
    els.thr.addEventListener(ev, updateUI);
    els.hold.addEventListener(ev, updateUI);
    els.fade.addEventListener(ev, updateUI);
  });
  updateUI();

  function enableButtons(){
    const ready = !!(backingBuf && vocalBuf) && !spotifyMode;
    els.start.disabled = !ready;
    els.cal.disabled = !ready;
  }

  async function ensureCtx(){
    if (!ctx){ ctx = new (window.AudioContext || window.webkitAudioContext)(); els.srText.textContent = ctx.sampleRate + ' Hz'; }
    await ctx.resume();
  }
  async function fileToAudioBuffer(file){ const ab = await file.arrayBuffer(); return await ctx.decodeAudioData(ab); }
  function mkSource(buf){ const s = ctx.createBufferSource(); s.buffer = buf; return s; }
  function ramp(param, target, ms){ const t = ctx.currentTime; const sec = Math.max(0.01, ms/1000); try{ param.cancelScheduledValues(t);}catch{} param.setValueAtTime(param.value, t); param.linearRampToValueAtTime(target, t+sec); }
  function setOverlay(on){ if (spotifyMode) return; if (overlayOn===on) return; overlayOn = on; ramp(vocalGain.gain, on?1.0:0.0, Number(els.fade.value)); els.statePill.textContent = (spotifyMode? 'Spotify Mode' : 'Vocal Overlay: ' + (on?'ON':'OFF')); els.statePill.classList.toggle('on', on && !spotifyMode); els.statePill.classList.toggle('off', !on || spotifyMode); }

  function computeRMS(){ const n=analyser.fftSize; const buf=new Float32Array(n); analyser.getFloatTimeDomainData(buf); let s=0; for(let i=0;i<n;i++){ const v=buf[i]; s+=v*v; } return Math.sqrt(s/n); }

  async function start(){
    if (spotifyMode) { alert('Spotify mode active â€” overlay graph disabled. Use Play on Spotify, or disconnect and load local files.'); return; }
    await ensureCtx();
    backingSrc = mkSource(backingBuf); vocalSrc = mkSource(vocalBuf);
    backingGain = ctx.createGain(); backingGain.gain.value = 1.0;
    vocalGain   = ctx.createGain();   vocalGain.gain.value = 1.0; // start ON until you sing
    const master = ctx.createGain(); master.gain.value = 1.0;
    const limiter = ctx.createDynamicsCompressor(); limiter.threshold.value = -2; limiter.knee.value = 0; limiter.ratio.value = 20; limiter.attack.value = 0.003; limiter.release.value = 0.050;
    backingSrc.connect(backingGain).connect(master); vocalSrc.connect(vocalGain).connect(master); master.connect(limiter).connect(ctx.destination);
    // mic (analysis only)
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:false } });
    const micSrcLocal = ctx.createMediaStreamSource(micStream); analyser = ctx.createAnalyser(); analyser.fftSize = 1024; analyser.smoothingTimeConstant = 0.7; micSrcLocal.connect(analyser);
    const startAt = ctx.currentTime + 0.08; backingSrc.start(startAt); vocalSrc.start(startAt); startWallClock = performance.now() + 80;
    let lastLoudTs = performance.now();
    logicTimer = setInterval(()=>{
      const rms = computeRMS(); els.rmsText.textContent = rms.toFixed(3); const pct = Math.min(100, Math.max(0, (rms / Number(els.thr.value)) * 100)); els.bar.style.width = pct + '%';
      if (rms > Number(els.thr.value)) { lastLoudTs = performance.now(); setOverlay(false); }
      else { const quietFor = performance.now() - lastLoudTs; if (quietFor >= Number(els.hold.value)) setOverlay(true); }
      updateLyricsUI();
    }, 50);
    els.start.disabled = true; els.stop.disabled = false; els.cal.disabled = false;
  }

  function stop(){ try{ backingSrc?.stop(); }catch{} try{ vocalSrc?.stop(); }catch{} if (logicTimer) clearInterval(logicTimer); if (micStream) micStream.getTracks().forEach(t=>t.stop()); overlayOn=false; setOverlay(false); els.start.disabled=false; els.stop.disabled=true; }

  async function calibrate(){ els.cal.textContent='Calibratingâ€¦ (2s)'; els.cal.disabled=true; const readings=[]; const endAt=performance.now()+2000; while(performance.now()<endAt){ await new Promise(r=>setTimeout(r,80)); if(analyser) readings.push(computeRMS()); } const ambient=readings.length? readings.reduce((a,b)=>a+b,0)/readings.length:0.005; els.thr.value=Math.max(0.003, ambient*1.8).toFixed(3); updateUI(); els.cal.textContent='ðŸ›  Calibrate Noise'; els.cal.disabled=false; }

  els.start.addEventListener('click', start); els.stop.addEventListener('click', stop); els.cal.addEventListener('click', calibrate);

  // ---------- Oneâ€‘file autoâ€‘separate ----------
  els.mixed.addEventListener('change', async()=>{ if (!els.mixed.files.length) return; spotifyMode=false; await ensureCtx(); const buf = await fileToAudioBuffer(els.mixed.files[0]); backingBuf = makeInstrumentalSideOnly(buf); vocalBuf = buf; enableButtons(); // try lyrics guess
    const guess = els.mixed.files[0].name.replace(/\.[^/.]+$/, '').split('-'); if (guess.length>=2) fetchLyrics(guess[0].trim(), guess[1].trim()); });

  function makeInstrumentalSideOnly(buf){ const { numberOfChannels, length, sampleRate } = buf; if (numberOfChannels===1){ const out=new AudioBuffer({length,sampleRate,numberOfChannels:1}); out.copyToChannel(buf.getChannelData(0),0); return out; } const L=buf.getChannelData(0), R=buf.getChannelData(1); const out=new AudioBuffer({length,sampleRate,numberOfChannels:2}); const oL=out.getChannelData(0), oR=out.getChannelData(1); for(let i=0;i<length;i++){ const S=0.5*(L[i]-R[i]); oL[i]=S; oR[i]=-S; } normalizeBuffer(out, 0.98); return out; }
  function normalizeBuffer(buffer, peak=0.98){ const { numberOfChannels, length } = buffer; let maxAbs=0; for(let ch=0; ch<numberOfChannels; ch++){ const d=buffer.getChannelData(ch); for(let i=0;i<length;i++){ const v=Math.abs(d[i]); if(v>maxAbs) maxAbs=v; } } if (maxAbs>0){ const g=peak/maxAbs; for(let ch=0; ch<numberOfChannels; ch++){ const d=buffer.getChannelData(ch); for(let i=0;i<length;i++) d[i]*=g; } } }

  // ---------- Twoâ€‘file flow ----------
  ;[els.backing, els.vocal].forEach(inp => inp.addEventListener('change', async()=>{ try{ spotifyMode=false; await ensureCtx(); if (els.backing.files.length) backingBuf = await fileToAudioBuffer(els.backing.files[0]); if (els.vocal.files.length) vocalBuf = await fileToAudioBuffer(els.vocal.files[0]); enableButtons(); }catch(e){ alert('Error decoding audio: ' + e.message); } }));

  // ---------- Lyrics upload (.lrc/.txt) ----------
  els.lyrFile.addEventListener('change', async()=>{ const f=els.lyrFile.files[0]; if(!f) return; const text=await f.text(); const isLRC=/\[[0-9]{1,2}:[0-9]{2}(?:\.[0-9]{1,2})?\]/.test(text); lyrics = isLRC ? parseLRC(text) : parsePlain(text); autoScrollIdx=0; updateLyricsUI(true); });
  els.lyrClear.addEventListener('click', ()=>{ lyrics=[]; autoScrollIdx=0; updateLyricsUI(true); });

  function parseLRC(txt){ const lines=txt.split(/\r?\n/); const out=[]; for(const line of lines){ const matches=[...line.matchAll(/\[([0-9]{1,2}):([0-9]{2})(?:\.([0-9]{1,2}))?\](.*)/g)]; if(!matches.length) continue; for(const m of matches){ const mm=parseInt(m[1]||'0',10), ss=parseInt(m[2]||'0',10), cs=parseInt(m[3]||'0',10); const t=mm*60+ss+(cs||0)/100; const text=(m[4]||'').trim(); if(text) out.push({t,text}); } } out.sort((a,b)=>a.t-b.t); return out; }
  function parsePlain(txt){ const lines=txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); return lines.map(s=>({t:null,text:s})); }
  function getPlaybackTime(){ if(!startWallClock) return 0; return (performance.now() - startWallClock)/1000; }
  function updateLyricsUI(force=false){ if(!lyrics.length){ els.lyrPrev.textContent='\u00a0'; els.lyrCurr.textContent='(no lyrics loaded)'; els.lyrNext.textContent='\u00a0'; return; } if(lyrics[0].t==null){ const now=performance.now(); if(!lyricsTimer||force){ lyricsTimer=now; autoScrollIdx=0; } const idx=Math.min(lyrics.length-1, Math.floor((now-lyricsTimer)/3000)); renderLyricIdx(idx); return; } const t=getPlaybackTime(); let idx=0; while(idx<lyrics.length && lyrics[idx].t<=t) idx++; idx=Math.max(0,idx-1); renderLyricIdx(idx); }
  function renderLyricIdx(idx){ const prev=lyrics[idx-1]?.text||'\u00a0', curr=lyrics[idx]?.text||'\u00a0', next=lyrics[idx+1]?.text||'\u00a0'; els.lyrPrev.textContent=prev; els.lyrCurr.textContent=curr; els.lyrNext.textContent=next; }

  // ---------- SEARCH via iTunes (30s) + LRCLIB ----------
  els.search.addEventListener('click', async()=>{ const q=els.q.value.trim(); if(!q) return alert('Enter a song title, optionally "title â€” artist"'); try{ spotifyMode=false; await ensureCtx(); const url = `https://itunes.apple.com/search?term=${encodeURIComponent(q)}&entity=song&limit=1`; const res = await fetch(url); if (!res.ok) throw new Error('Search failed'); const data = await res.json(); if (!data.results || !data.results.length) throw new Error('No results'); const item = data.results[0]; const previewUrl = item.previewUrl; els.art.src = item.artworkUrl100?.replace('100x100bb', '200x200bb') || ''; els.songMeta.textContent = `${item.trackName} â€” ${item.artistName}`; const ab = await (await fetch(previewUrl)).arrayBuffer(); const buf = await ctx.decodeAudioData(ab); backingBuf = makeInstrumentalSideOnly(buf); vocalBuf = buf; enableButtons(); fetchLyrics(item.trackName, item.artistName); } catch(err){ console.error(err); alert('Search failed or blocked. You can still upload files manually.'); } });

  async function fetchLyrics(title, artist){ try{ const api = `https://lrclib.net/api/search?track_name=${encodeURIComponent(title)}&artist_name=${encodeURIComponent(artist)}`; const r = await fetch(api, { headers: { 'Accept':'application/json' } }); if (!r.ok) throw new Error('lyrics not found'); const arr = await r.json(); if (!arr || !arr.length) return; const hit = arr[0]; if (hit.syncedLyrics) { lyrics = parseLRC(hit.syncedLyrics); } else if (hit.plainLyrics) { lyrics = parsePlain(hit.plainLyrics); } autoScrollIdx = 0; updateLyricsUI(true); }catch(e){ console.log('lyrics lookup failed', e); } }

  // ---------- Spotify Web Playback SDK (overlay disabled) ----------
  ;(function loadSpotifySDK(){ if (document.getElementById('spotify-player')) return; const s=document.createElement('script'); s.id='spotify-player'; s.src='https://sdk.scdn.co/spotify-player.js'; document.body.appendChild(s); })();

  // Edit these two values for your app:
  const SPOTIFY_CLIENT_ID = 'YOUR_SPOTIFY_CLIENT_ID';
  const SPOTIFY_REDIRECT_URI = window.location.origin + '/'; // or a dedicated callback path you set in Dashboard
  const SPOTIFY_SCOPES = [ 'streaming','user-read-email','user-read-private','user-modify-playback-state','user-read-playback-state' ].join(' ');

  function b64url(a){ return btoa(String.fromCharCode.apply(null, new Uint8Array(a))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
  async function sha256(v){ const data=new TextEncoder().encode(v); return await crypto.subtle.digest('SHA-256', data); }
  function randStr(n=64){ const p='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'; let s=''; for(let i=0;i<n;i++) s+=p[Math.floor(Math.random()*p.length)]; return s; }
  async function beginSpotifyLogin(){ const verifier=randStr(64); const challenge=b64url(await sha256(verifier)); sessionStorage.setItem('sp_pkce_verifier', verifier); const params=new URLSearchParams({ client_id:SPOTIFY_CLIENT_ID, response_type:'code', redirect_uri:SPOTIFY_REDIRECT_URI, code_challenge_method:'S256', code_challenge:challenge, scope:SPOTIFY_SCOPES }); location.assign('https://accounts.spotify.com/authorize?' + params.toString()); }
  async function completeSpotifyLoginIfRedirect(){ const url=new URL(location.href); const code=url.searchParams.get('code'); if(!code) return null; history.replaceState({}, '', SPOTIFY_REDIRECT_URI); const verifier=sessionStorage.getItem('sp_pkce_verifier'); const body=new URLSearchParams({ client_id:SPOTIFY_CLIENT_ID, grant_type:'authorization_code', code, redirect_uri:SPOTIFY_REDIRECT_URI, code_verifier:verifier }); const r=await fetch('https://accounts.spotify.com/api/token', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body }); if(!r.ok) throw new Error('Token exchange failed'); const tok=await r.json(); sessionStorage.setItem('sp_access_token', tok.access_token); sessionStorage.setItem('sp_expires_at', (Date.now() + (tok.expires_in-60)*1000).toString()); return tok.access_token; }
  function getSpotifyToken(){ const t=sessionStorage.getItem('sp_access_token'); const exp=Number(sessionStorage.getItem('sp_expires_at')||0); return (t && Date.now()<exp)? t:null; }

  let spPlayer=null, spDeviceId=null;
  window.onSpotifyWebPlaybackSDKReady = () => { /* instantiated after login */ };

  async function ensureSpotifyPlayer(){ if(spPlayer) return spPlayer; const token=getSpotifyToken(); if(!token) throw new Error('No Spotify token'); spPlayer = new Spotify.Player({ name:'Dynamic Karaoke Player', getOAuthToken: cb=>cb(getSpotifyToken()), volume:0.9 }); spPlayer.addListener('ready', ({device_id}) => { spDeviceId = device_id; }); spPlayer.addListener('initialization_error', ({message})=>console.error(message)); spPlayer.addListener('authentication_error', ({message})=>console.error(message)); spPlayer.addListener('account_error', ({message})=>console.error(message)); await spPlayer.connect(); return spPlayer; }

  function extractTrackUri(input){ if(!input) return null; if(input.startsWith('spotify:track:')) return input; const m=input.match(/open\.spotify\.com\/track\/([A-Za-z0-9]+)/); return m? `spotify:track:${m[1]}`: null; }
  async function transferAndPlay(uri){ const token=getSpotifyToken(); // transfer playback
    await fetch('https://api.spotify.com/v1/me/player', { method:'PUT', headers:{'Authorization':'Bearer '+token,'Content-Type':'application/json'}, body: JSON.stringify({ device_ids:[spDeviceId], play:true }) });
    await fetch('https://api.spotify.com/v1/me/player/play?device_id='+encodeURIComponent(spDeviceId), { method:'PUT', headers:{'Authorization':'Bearer '+token,'Content-Type':'application/json'}, body: JSON.stringify({ uris:[uri] }) }); }

  els.spLoginBtn.addEventListener('click', async()=>{ try{ await beginSpotifyLogin(); }catch(e){ alert(e.message); } });
  (async()=>{ try{ const tok=await completeSpotifyLoginIfRedirect(); if(tok || getSpotifyToken()){ await ensureSpotifyPlayer(); els.spPlayBtn.disabled=false; // switch UI to Spotify mode (disable overlay graph)
        spotifyMode = true; try { if (typeof stop === 'function') stop(); } catch {} els.statePill.classList.add('off'); els.statePill.textContent='Spotify Mode (overlay disabled)'; els.start.disabled=true; els.cal.disabled=true; }
    }catch(e){ console.warn('Spotify auth err', e); } })();
  els.spPlayBtn.addEventListener('click', async()=>{ try{ const uri=extractTrackUri(els.spTrackInp.value.trim()); if(!uri) return alert('Paste a Spotify track URL or URI'); await ensureSpotifyPlayer(); await transferAndPlay(uri); }catch(e){ alert(e.message||'Failed to play'); } });

  // ---------- Ready state check ----------
  document.addEventListener('change', ()=> enableButtons());
  </script>
</body>
</html>
